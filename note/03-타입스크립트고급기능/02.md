# 2. 맵드 타입(mapped type)

맵드 타입 mapped type을 이용해서 모든 속성을 optional로 바꾸거나 readonly로 바꾸는 등의 일을 할 수 있다.

```ts
interface Person {
    name: string;
    age: number;
}

interface PersonOptional {
    name?: string;
    age?: number;
}

interface PersonReadOnly {
    readonly name: string;
    readonly age: number;
}
```

```ts
// mapped type 문법
type T1 = { 
    [K in 'prop1' | 'prop2']: boolean 
};

// 두 코드는 같다.

type T1 = {
    prop1: boolean;
    prop2: boolean;
}
```

맵드 타입으로 만들어지는 건 객체이기 때문에 중괄호를 사용한다.

[]는 key부분을 뜻한다.

K는 아무 이름으로 작성해도 상관 없고 in 오른쪽이 중요하다.

현재 두 개의 문자열 리터럴을 유니온 타입으로 지정한 상황이다.

```ts
interface Person {
    name: string;
    age: number;
}

// T의 모든 key값을 선택속성이고 boolean 타입으로 지정한다.
type MakeBoolean<T> = { [P in keyof T]?: boolean };
const pMap: MakeBoolean<Person> = {};

pMap.name = true;
pMap.age = false;
pMap.age = undefined; // 선택 속성이기 때문에 사용 가능
pMap.age = 1; // error.
```

T라는 값의 key의 union값을 이용하여 key를 만들고 그걸 선택속성으로 지정된다.

따라서 pMap의 name과 age에는 boolean과 undefined는 입력 가능하지면 number는 불가능하다.

```ts
interface Person {
    name: string;
    age: number;
}

// 인터페이스의 key값을 index로 잡으면  해당 속성의 타입이 리턴된다. 
type T1 = Person['name']; // string
type ReadonlyType<T> = { readonly [P in keyof T]: T[P] }; // readonly로 바꾸고 원래 속성의 타입을 그대로 유지하겠다.
type PartialType<T> = { [P in keyof T]?: T[P] }; // optional로 바꾸고 원래 속성의 타입을 그대로 유지하겠다.
type T2 = ReadonlyType<Person>; 
type T3 = PartialType<Person>;
```

위코드의 결과로

```ts
type T2 = {
    readonly name: string;
    readonly age: number;
}

type T3 = {
    name?: string;
    age?: number;
}
```

가 된다. 하지만 사실 여기서 Readonly와 Partial은 타입스크립트 내장 타입이기 때문에 

```ts
interface Person {
    name: string;
    age: number;
}

type T2 = ReadonlyType<Person>; 
type T3 = PartialType<Person>;
```

이렇게만 해도 동일한 결과를 얻을 수 있다.

```ts
// type Pick<T, K extends keyof T> = { [P in K]: T[P] };

interface Person {
    name: string;
    age: number;
    language: string;
}

type T1 = Pick<Person, 'name' | 'language'>;
```

Pick이라는 내장 맵드 타입이 있다.

Pick은 두 개의 제네릭을 받는데, 하나는 T라는 인터페이스이고, 하나는 T의 key의 union값의 부분집합인 K를 받는다.

그 둘을 받아서 처리하면 아래와 같다.

```ts
type T1 = {
    name: string;
    age: string;
}
```

```ts
interface Person {
    name: string;
    age: number;
    language: string;
}

// type Record<K extends string, T> = { [P in K]: T };

type T1 = Record<'p1' | 'p2', Person>
type T2 = Record<'p1' | 'p2', number>
```

Record라는 내장 타입은 문자열로 이루어진 제네릭과 타입을 받는다. 

그리고 아래와 같은 값을 반환한다.

```ts
type T1 = {
    p1: Person,
    p2: Person,
}

type T2 = {
    p1: number,
    p2: number,
}
```

맵드 타입을 이용하면 enum 타입의 활용도를 높일 수 있다.

```ts
enum Fruit {
    Apple,
    Banana,
    Orange
}

const FRUIT_PRICE = {
    [Fruit.Apple]: 1000,
    [Fruit.Banana]: 1500,
    [Fruit.Orange]: 2000
}
```

위와 같은 코드가 있을 때, enum 타입에 변화가 발생하면 아래 FRUIT_PRICE에서 변화가 있어야 한다.

```ts
enum Fruit {
    Apple,
    Banana,
    Orange,
    Orange2,
}

const FRUIT_PRICE = {
    [Fruit.Apple]: 1000,
    [Fruit.Banana]: 1500,
    [Fruit.Orange]: 2000,
    [Fruit.Orange2]: 2500,
}
```

위와 같이 코드를 바꿔줘야 하는데 이는 실수가 생길 여지가 많다.

```ts
enum Fruit {
    Apple,
    Banana,
    Orange,
    Orange2,
}


// error
const FRUIT_PRICE: { [key in Fruit]: number } = {
    [Fruit.Apple]: 1000,
    [Fruit.Banana]: 1500,
}
```

이렇게 in 오른쪽에 enum 타입을 작성하면 enum내 모든 아이템을 나열해야만 한다.

Orange와 Orange2를 모두 정의해줘야 error가 해제된다.

```ts
// good
enum Fruit {
    Apple,
    Banana,
    Orange,
    Orange2,
}

const FRUIT_PRICE: { [key in Fruit]: number } = {
    [Fruit.Apple]: 1000,
    [Fruit.Banana]: 1500,
    [Fruit.Orange]: 2000,
    [Fruit.Orange2]: 2500,
}
```